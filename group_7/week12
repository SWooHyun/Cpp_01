일반화와 템플릿

제네릭(generic) 또는 일반화
함수나 클래스를 일반화시키고, 매개 변수 타입을 지정하여 틀에서 찍어 내듯이
함수나 클래스 코드를 생산하는 기법
템플릿
함수나 클래스를 일반화하는 C++ 도구
template 키워드로 함수나 클래스 선언
변수나 매개 변수의 타입만 다르고, 코드 부분이 동일한 함수를 일반화시킴
제네릭 타입 - 일반화를 위한 데이터 타입

템플릿 선언

template <class T> 또는
template <typename T>
3 개의 제네릭 타입을 가진 템플릿 선언
template <class T1, class T2, class T3>


템플릿 장점과 제네릭 프로그래밍

템플릿 장점
함수 코드의 재사용
높은 소프트웨어의 생산성과 유용성


템플릿 단점
포팅에 취약
컴파일러에 따라 지원하지 않을 수 있음
컴파일 오류 메시지 빈약, 디버깅에 많은 어려움
제네릭 프로그래밍
generic programming
일반화 프로그래밍이라고도 부름
제네릭 함수나 제네릭 클래스를 활용하는 프로그래밍 기법
C++에서 STL(Standard Template Library) 제공. 활용
보편화 추세
Java, C# 등 많은 언어에서 활용

C++ 표준 템플릿 라이브러리, STL

STL(Standard Template Library)
표준 템플릿 라이브러리
C++ 표준 라이브러리 중 하나
많은 제네릭 클래스와 제네릭 함수 포함
개발자는 이들을 이용하여 쉽게 응용 프로그램 작성
STL의 구성
컨테이너 – 템플릿 클래스
데이터를 담아두는 자료 구조를 표현한 클래스
리스트, 큐, 스택, 맵, 셋, 벡터
iterator – 컨테이너 원소에 대한 포인터
컨테이너의 원소들을 순회하면서 접근하기 위해 만들어진 컨테이너 원소에 대한 포인터
알고리즘 – 템플릿 함수
컨테이너 원소에 대한 복사, 검색, 삭제, 정렬 등의 기능을 구현한 템플릿함수
컨테이너의 멤버 함수 아님

STL과 관련된 헤더 파일과 이름 공간
헤더파일
컨테이너 클래스를 사용하기 위한 헤더 파일
해당 클래스가 선언된 헤더 파일 include
 예) vector 클래스를 사용하려면 #include <vector>
list 클래스를 사용하려면 #include <list>
알고리즘 함수를 사용하기 위한 헤더 파일
알고리즘 함수에 상관 없이 #include <algorithm>
이름 공간
STL이 선언된 이름 공간은 std

iterator 사용
iterator란?
반복자라고도 부름
컨테이너의 원소를 가리키는 포인터
iterator 변수 선언
구체적인 컨테이너를 지정하여 반복자 변수 생성


map 컨테이너
특징
(‘키’, ‘값’)의 쌍을 원소로 저장하는 제네릭 컨테이너
동일한 ‘키’를 가진 원소가 중복 저장되면 오류 발생
‘키’로 ‘값‘ 검색
많은 응용에서 필요함
#include <map> 필요
맵 컨테이너 생성 예
영한 사전을 저장하기 위한 맵 컨테이너 생성 및 활용
영어 단어와 한글 단어를 쌍으로 저장하고, 영어 단어로 검색

// 맵 생성
Map<string, string> dic; // 키는 영어 단어, 값은 한글 단어
// 원소 저장
dic.insert(make_pair("love", "사랑")); // ("love", "사랑") 저장
dic["love"] = "사랑"; // ("love", "사랑") 저장
// 원소 검색
string kor = dic["love"]; // kor은 "사랑“
string kor = dic.at("love“); // kor은 "사랑"

STL 알고리즘 사용하기
알고리즘 함수
템플릿 함수
전역 함수
STL 컨테이너 클래스의 멤버 함수가 아님
iterator와 함께 작동

sort() 함수 사례
두 개의 매개 변수
첫 번째 매개 변수 : 소팅을 시작한 원소의 주소
두 번째 매개 변수 : 소팅 범위의 마지막 원소 다음 주소

vector<int> v;
...
sort(v.begin(), v.begin()+3); // v.begin()에서 v.begin()+2까지, 처음 3개 원소 정렬
sort(v.begin()+2, v.begin()+5); // 벡터의 3번째 원소에서 v.begin()+4까지, 3개 원소 정렬
sort(v.begin(), v.end()); // 벡터 전체 정렬


auto를 이용하여 쉬운 변수 선언
C++에서 auto기능
C++11부터 auto 선언의 의미 수정 : 컴파일러에게 변수선언문에서추론하여 타입을 자동 선언하도록 지시
C++11 이전까지는 스택에 할당되는 지역 변수를 선언하는 키워드

장점
복잡한 변수 선언을 간소하게, 긴 타입 선언 시 오타 줄임

auto의 기본 사용 사례
auto pi = 3.14; // 3.14가 실수이므로 pi는 double 타입으로 선언됨
auto n = 3; // 3이 정수이므로 n을 int 타입으로
auto *p = &n; // 변수 p는 int* 타입으로 추론
int n = 10;
int & ref = n; // ref는 int에 대한 참조 변수
auto ref2 = ref; // ref2는 int& 변수로 자동 선언

람다
람다 대수와 람다식
람다 대수에서 람다식은 수학 함수를 단순하게 표현하는 기법

C++에서 람다식 선언
C++의 람다식의 구성
4 부분으로 구성
캡쳐 리스트 : 람다식에서 사용하고자 하는 함수 바깥의 변수 목록
매개변수 리스트 : 보통 함수의 매개변수 리스트와 동일
리턴 타입
함수 바디 : 람다식의 함수 코드
